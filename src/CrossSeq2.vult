
fun soft(x1) {
   mem x2,x3,x4;
   val o = (x1+x2+x3+x4)/4.0;
   x2,x3,x4 = x1,x2,x3;
   return o;
}

fun change(x:real):bool {
    mem pre_x;
    val v:bool = pre_x <> x;
    pre_x = x;
    return v;
}

fun edge(x:bool) : bool {
   mem pre;
   val ret = x && not(pre);
   pre = x;
   return ret;
}

// Returns true every 'n' calls
fun each(n){
   mem count;
   val ret = (count == 0);
   count = (count + 1) % n;
   return ret;
}

fun lerp(a,b,i){

    return a * (1.0 - i) + (b *  i);
}

fun lfo_interp(cv, shape, amt, pw, reset, phaseOff, sampleTime) {
   mem rate; 
   mem phase;
   mem o;
   mem phOff;
   if(change(phaseOff))
      phOff = phaseOff;
   if(change(cv))
      rate = cv * sampleTime * 8.0;
   val update = each(8); 
   if(update)
      phase = phase + rate;
   phase = phase % 2.0;
   val ph = (phase + phOff) % 2.0;
   //for smooth interpolation between sine and tri I need to offset the phase of the
   //tri
   val offset_phase = if ph + 0.5 > 2.0 then (ph + 0.5) - 2.0 else ph + 0.5;
   val breset = reset > 0.0;
   if(edge(breset))
      phase = 0.0;
   val saw = ph - 1.0;
   offset_phase = offset_phase - 1.0;
   if(update)
      o =
         if shape < 1.0 then 
            lerp((sin(ph*3.141592653589793)), (abs(offset_phase) * 2.0 - 1.0)*-1.0, shape % 1.0)*amt
         else if shape < 2.0 then
            lerp((abs(offset_phase) * 2.0 - 1.0)*-1.0, saw, shape % 1.0)*amt
         else if shape < 3.0 then 
            lerp(saw, (if saw > pw then 1.0 else -1.0), shape % 1.0)*amt
         else
            (if saw > pw then 1.0 else -1.0)*amt;
   return soft(o);
}
and initPhase()@[init]{
   phase = 0.0;
   rate = 1.0;
   phOff = 0.0;
}

fun cross_detect(a:real, b:real, st:real)
{
   mem open:real;
   open = open + st;
   val diff = a - b;
   val sign = if diff > 0.0 then 1.0 else 0.0;
   if (change(sign))
      open = 0.0;
   return if open > 0.001 then 0.0 else 1.0;
}


fun process(sampleTime:real){
   mem sync, freq, rate1, rate2, amt1, amt2, shape1, shape2, pw1, pw2, phaseOff1, phaseOff2;
   val lfo1 = lfo_interp(rate1*freq, shape1, amt1, pw1, sync,phaseOff1, sampleTime) ;
   val lfo2 = lfo_interp(rate2*freq, shape2, amt2, pw2, sync,phaseOff2, sampleTime) ;
   val gate = cross_detect(lfo1, lfo2, sampleTime);
   val trig = gate;
   val diff = (lfo1 - lfo2) ;//  / (amt1 + amt2);
   //return trig, lfo1 / (amt1 + 0.001), lfo2 / (amt2 + 0.001), diff ; 
   return trig, lfo1 , lfo2 , diff ; 
}
and setFreq(knob:real, input:real){
   freq = knob + input;
}
and setSync(value:real){
   sync = value;
}
and setRate1(knob:real, input:real){
   rate1 = knob + input;
}
and setRate2(knob:real, input:real){
   rate2 = knob + input;
}
and setPhase1(phaseKnob:real){
   phaseOff1 = phaseKnob;
}
and setPhase2(phaseKnob:real){
   phaseOff2 = phaseKnob;
}

and setAmt1(knob:real, input:real){
   amt1 = clip(knob + input, 0.0, 1.0);
}
and setAmt2(knob:real, input:real){
   amt2 = clip(knob + input, 0.0, 1.0);
}
and setShape1(knob:real, input:real){
   shape1 = knob + input;
}
and setShape2(knob:real, input:real){
   shape2 = knob + input;
}
and setPw1(knob:real){
   pw1 = knob * 2. - 1.;
}
and setPw2(knob:real){
   pw2 = knob * 2. - 1.;
}


// Called on initialization to define initial values
and default() @[init]{
   freq = 1.0;
   sync = 0.0;
   rate1 = 1.0;
   rate2 = 1.0;
   amt1 = 1.0;
   amt2 = 1.0;
   shape1 = 0.0;
   shape2 = 1.0;
   phaseOff1 = 0.0;
   phaseOff2 = 0.0;
   pw1 = 0.5;
   pw2 = 0.5;
}