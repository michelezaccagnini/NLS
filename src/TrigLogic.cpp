
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "TrigLogic.h"

int TrigLogic_direction(TrigLogic__ctx_type_0 &_ctx, float x){
   float dir;
   dir = (x + (- _ctx.pre));
   int ret;
   if(dir > 0.0f){
      ret = 1;
   }
   else
   {
      if(dir < 0.0f){
         ret = (-1);
      }
      else
      {
         ret = 0;
      }
   }
   _ctx.pre = x;
   return ret;
}

int TrigLogic_sign(float x){
   int ret;
   if(x > 0.0f){
      ret = 1;
   }
   else
   {
      if(x < 0.0f){
         ret = (-1);
      }
      else
      {
         ret = 0;
      }
   }
   return ret;
}

void TrigLogic__ctx_type_2_init(TrigLogic__ctx_type_2 &_output_){
   TrigLogic__ctx_type_2 _ctx;
   TrigLogic__ctx_type_0_init(_ctx._inst2b9);
   TrigLogic__ctx_type_0_init(_ctx._inst1b9);
   _output_ = _ctx;
   return ;
}

uint8_t TrigLogic_logic(TrigLogic__ctx_type_2 &_ctx, float x1, float x2, uint8_t type1, uint8_t type2, int s1, int s2, uint8_t andOr){
   uint8_t res1;
   uint8_t res2;
   int tmp1;
   int tmp2;
   if(type1){
      tmp1 = TrigLogic_direction(_ctx._inst1b9,x1);
   }
   else
   {
      tmp1 = TrigLogic_sign(x1);
   }
   if(type2){
      tmp2 = TrigLogic_direction(_ctx._inst2b9,x2);
   }
   else
   {
      tmp2 = TrigLogic_sign(x2);
   }
   res1 = (s1 == tmp1);
   res2 = (s2 == tmp2);
   uint8_t ret;
   if(andOr){
      ret = (res1 && res2);
   }
   else
   {
      ret = (res1 || res2);
   }
   return ret;
}

void TrigLogic__ctx_type_3_init(TrigLogic__ctx_type_3 &_output_){
   TrigLogic__ctx_type_3 _ctx;
   _ctx.type2 = false;
   _ctx.type1 = false;
   _ctx.s2 = 0;
   _ctx.s1 = 0;
   _ctx.process_ret_1 = 0.0f;
   _ctx.process_ret_0 = 0.0f;
   _ctx.pre = 0.0f;
   _ctx.inv = false;
   _ctx.andOr = false;
   TrigLogic__ctx_type_2_init(_ctx._inst129);
   TrigLogic_default(_ctx);
   _output_ = _ctx;
   return ;
}

void TrigLogic_process(TrigLogic__ctx_type_3 &_ctx, float trig, float lfo1, float lfo2){
   uint8_t l;
   l = TrigLogic_logic(_ctx._inst129,lfo1,lfo2,_ctx.type1,_ctx.type2,_ctx.s1,_ctx.s2,_ctx.andOr);
   float ret1;
   if(l){
      ret1 = trig;
   }
   else
   {
      ret1 = 0.0f;
   }
   float ret2;
   if(bool_not(l)){
      ret2 = trig;
   }
   else
   {
      ret2 = 0.0f;
   }
   _ctx.process_ret_0 = ret1;
   _ctx.process_ret_1 = ret2;
   return ;
}

void TrigLogic_default(TrigLogic__ctx_type_3 &_ctx){
   _ctx.type1 = true;
   _ctx.type2 = true;
   _ctx.s1 = 1;
   _ctx.s2 = 1;
   _ctx.andOr = true;
   _ctx.inv = false;
   _ctx.pre = 0.0f;
}


